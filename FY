{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":23023,"status":"ok","timestamp":1704681472136,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"1JZqF-BVtVZo","outputId":"2e389d2f-987b-4945-bd37-b468fa8229c5"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/gdrive\n"]}],"source":["\n","from google.colab import drive\n","drive.mount('/content/gdrive')\n"]},{"cell_type":"markdown","metadata":{"id":"LCF2zAI-rMgI"},"source":[]},{"cell_type":"code","execution_count":2,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":578,"status":"ok","timestamp":1704681474494,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"lLgeaW7AtepA","outputId":"f59fd095-5d08-4f4a-f3ea-25af7188035e"},"outputs":[{"output_type":"stream","name":"stdout","text":["/content/gdrive/MyDrive\n"]}],"source":["cd gdrive/MyDrive/"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":668,"status":"ok","timestamp":1704677188955,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"NslwYcQCtkFs","outputId":"db83f043-8480-4316-d6a7-06c6e55bfd21"},"outputs":[{"output_type":"stream","name":"stdout","text":["total 2975707\n","-rw------- 1 root       8203 Nov 27 12:21 AddF1.ipynb\n","-rw------- 1 root 2501632000 Nov 16 07:04 archive.tar\n","-rw------- 1 root      29512 Nov 29 05:24 FY\n","drwx------ 2 root       4096 Nov 29 04:49 \u001b[0m\u001b[01;34msrc\u001b[0m/\n","-rw------- 1 root  545449378 Nov 17 10:04 your_model.pth\n"]}],"source":["ll"]},{"cell_type":"markdown","metadata":{"id":"wK6kPUqXrMrj"},"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":167648,"status":"ok","timestamp":1701233552502,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"wuVYCBVJtk7h","outputId":"dc3b0166-5508-4855-a7d3-5db3228c9d48"},"outputs":[{"output_type":"stream","name":"stdout","text":["解压完成。文件已提取到当前目录。\n"]}],"source":["import tarfile\n","\n","# 定义tar文件路径\n","tar_file_path = 'archive.tar'\n","\n","# 打开tar文件并解压到当前目录\n","with tarfile.open(tar_file_path, 'r:') as tar:\n","    tar.extractall()\n","\n","print(f\"解压完成。文件已提取到当前目录。\")\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":11473,"status":"ok","timestamp":1701233563973,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"bl9AB3GWRG3e","outputId":"3f43d28f-8980-464d-abf8-7887cadd321e"},"outputs":[{"output_type":"stream","name":"stdout","text":["Collecting intel_extension_for_pytorch\n","  Downloading intel_extension_for_pytorch-2.1.0-cp310-cp310-manylinux2014_x86_64.whl (51.4 MB)\n","\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m51.4/51.4 MB\u001b[0m \u001b[31m7.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25hRequirement already satisfied: psutil in /usr/local/lib/python3.10/dist-packages (from intel_extension_for_pytorch) (5.9.5)\n","Requirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (from intel_extension_for_pytorch) (1.23.5)\n","Requirement already satisfied: packaging in /usr/local/lib/python3.10/dist-packages (from intel_extension_for_pytorch) (23.2)\n","Installing collected packages: intel_extension_for_pytorch\n","Successfully installed intel_extension_for_pytorch-2.1.0\n"]}],"source":["pip install intel_extension_for_pytorch"]},{"cell_type":"code","execution_count":3,"metadata":{"executionInfo":{"elapsed":6562,"status":"ok","timestamp":1704681527051,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"Jz2iprXnuG0N"},"outputs":[],"source":["import os\n","import torch\n","from torch.utils.data import Dataset, DataLoader\n","from torchvision import transforms\n","from PIL import Image\n","import torch.nn as nn\n","import torch.optim as optim\n","from torch.optim.lr_scheduler import StepLR\n","from sklearn.metrics import f1_score\n","import torchvision.models as models\n","import time\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"toFOxvyQSm-Q"},"outputs":[],"source":["import intel_extension_for_pytorch as ipex"]},{"cell_type":"code","execution_count":4,"metadata":{"executionInfo":{"elapsed":376,"status":"ok","timestamp":1704681553159,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"h15fcDktuNNn"},"outputs":[],"source":["# 创建自定义数据集\n","class SelfDataset(Dataset):\n","    def __init__(self, root_dir, transform=None):\n","        self.root_dir = root_dir\n","        self.transform = transform\n","        self.classes = ['NORMAL', 'PNEUMONIA']\n","        self.data = self.load_data()\n","\n","    def load_data(self):\n","        data = []\n","        for class_idx, class_name in enumerate(self.classes):\n","            class_path = os.path.join(self.root_dir, class_name)\n","            for file_name in os.listdir(class_path):\n","                file_path = os.path.join(class_path, file_name)\n","                if os.path.isfile(file_path) and file_name.lower().endswith('.jpeg'):\n","                    data.append((file_path, class_idx))\n","        return data\n","\n","    def __len__(self):\n","        return len(self.data)\n","\n","    def __getitem__(self, idx):\n","        img_path, label = self.data[idx]\n","        img = Image.open(img_path).convert('RGB')\n","        if self.transform:\n","            img = self.transform(img)\n","        return img, label\n"]},{"cell_type":"code","execution_count":5,"metadata":{"executionInfo":{"elapsed":3138,"status":"ok","timestamp":1704681604947,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"XgdZdRuruO5R"},"outputs":[],"source":["# 数据集路径\n","train_dataset_path = './src/chest_xray/train'\n","test_dataset_path = './src/chest_xray/test'\n","val_dataset_path = './src/chest_xray/val'\n","\n","# 数据增强\n","transform = transforms.Compose([\n","    transforms.RandomResizedCrop(64),\n","    transforms.RandomHorizontalFlip(),\n","    transforms.ToTensor(),\n","])\n","\n","\n","# 创建数据集实例\n","train_dataset = SelfDataset(root_dir=train_dataset_path, transform=transform)\n","test_dataset = SelfDataset(root_dir=test_dataset_path, transform=transform)\n","val_dataset = SelfDataset(root_dir=val_dataset_path, transform=transform)\n","\n","# 创建 DataLoader\n","batch_size = 64\n","train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)\n","test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)\n","val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6936,"status":"ok","timestamp":1701233582574,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"d6v6C8CauQ3_","outputId":"b984e749-2b5d-480a-81b2-0a39c5dfbe98"},"outputs":[{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.10/dist-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and may be removed in the future, please use 'weights' instead.\n","  warnings.warn(\n","/usr/local/lib/python3.10/dist-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and may be removed in the future. The current behavior is equivalent to passing `weights=VGG16_Weights.IMAGENET1K_V1`. You can also use `weights=VGG16_Weights.DEFAULT` to get the most up-to-date weights.\n","  warnings.warn(msg)\n","Downloading: \"https://download.pytorch.org/models/vgg16-397923af.pth\" to /root/.cache/torch/hub/checkpoints/vgg16-397923af.pth\n","100%|██████████| 528M/528M [00:05<00:00, 108MB/s]\n"]}],"source":["vgg16_model = models.vgg16(pretrained=True)\n","\n","# 如果需要微调，可以解冻最后几层\n","for param in vgg16_model.features.parameters():\n","    param.requires_grad = False\n","\n","# 修改分类层\n","num_features = vgg16_model.classifier[6].in_features\n","vgg16_model.classifier[6] = nn.Sequential(\n","    nn.Linear(num_features, 512),\n","    nn.ReLU(),\n","    nn.Dropout(0.5),\n","    nn.Linear(512, 2)\n",")\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":9694,"status":"ok","timestamp":1701233592266,"user":{"displayName":"林武","userId":"07341959912096625029"},"user_tz":-480},"id":"fKheqCkUuTGi","outputId":"30a17644-0568-4cfc-cbbe-913d352afabd"},"outputs":[{"output_type":"execute_result","data":{"text/plain":["VGG(\n","  (features): Sequential(\n","    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (1): ReLU(inplace=True)\n","    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (3): ReLU(inplace=True)\n","    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n","    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (6): ReLU(inplace=True)\n","    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (8): ReLU(inplace=True)\n","    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n","    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (11): ReLU(inplace=True)\n","    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (13): ReLU(inplace=True)\n","    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (15): ReLU(inplace=True)\n","    (16): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n","    (17): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (18): ReLU(inplace=True)\n","    (19): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (20): ReLU(inplace=True)\n","    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (22): ReLU(inplace=True)\n","    (23): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n","    (24): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (25): ReLU(inplace=True)\n","    (26): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (27): ReLU(inplace=True)\n","    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n","    (29): ReLU(inplace=True)\n","    (30): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)\n","  )\n","  (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))\n","  (classifier): Sequential(\n","    (0): Linear(in_features=25088, out_features=4096, bias=True)\n","    (1): ReLU(inplace=True)\n","    (2): Dropout(p=0.5, inplace=False)\n","    (3): Linear(in_features=4096, out_features=4096, bias=True)\n","    (4): ReLU(inplace=True)\n","    (5): Dropout(p=0.5, inplace=False)\n","    (6): Sequential(\n","      (0): Linear(in_features=4096, out_features=512, bias=True)\n","      (1): ReLU()\n","      (2): Dropout(p=0.5, inplace=False)\n","      (3): Linear(in_features=512, out_features=2, bias=True)\n","    )\n","  )\n",")"]},"metadata":{},"execution_count":13}],"source":["criterion = nn.CrossEntropyLoss()\n","optimizer = optim.Adam(vgg16_model.parameters(), lr=0.001, weight_decay=1e-4)\n","\n","\n","# 添加学习率调度器\n","# 使用 ReduceLROnPlateau 调度器\n","scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', factor=0.1, patience=3, verbose=True)\n","\n","\n","# 训练参数\n","device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n","vgg16_model.to(device)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"-WY8y6cQUPTC"},"outputs":[],"source":["# # 将模型参数移回 CPU\n","# vgg16_model = vgg16_model.to('cpu')\n","\n","# # 重新构建优化器\n","# optimizer = optim.Adam(vgg16_model.parameters(), lr=0.001, weight_decay=1e-4)\n","\n","# # 使用 Intel Extension for PyTorch 进行优化\n","# vgg16_model, optimizer = ipex.optimize(model=vgg16_model, optimizer=optimizer, dtype=torch.float32)\n","# scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', factor=0.1, patience=3, verbose=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"i6T7xtJoUtoQ"},"outputs":[],"source":["# # 将模型参数移回 CPU\n","# vgg16_model = vgg16_model.to('cpu')\n","\n","# # 重新构建优化器\n","# optimizer = optim.Adam(vgg16_model.parameters(), lr=0.001, weight_decay=1e-4)\n","\n","# # 使用 Intel Extension for PyTorch 进行优化\n","# vgg16_model, optimizer = ipex.optimize(model=vgg16_model, optimizer=optimizer, dtype=torch.float32)\n","\n","# # 绑定调度器到原始模型上\n","# scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', factor=0.1, patience=3, verbose=True)\n","# device = torch.device('cpu')\n","# vgg16_model.to(device)\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"VyB0loLRJqKC","outputId":"bab6cb71-26b2-45d1-e98b-9e22c08c8e06"},"outputs":[{"output_type":"stream","name":"stdout","text":["第1次训练开始了\n","Epoch [1], 第1轮：训练集损失: 0.4447, 验证集损失: 0.8178\n","测试集用的时间为: 9.17 seconds\n","第1轮的测试F1分数: 0.8775\n","第2次训练开始了\n","Epoch [2], 第2轮：训练集损失: 0.3231, 验证集损失: 1.7962\n","测试集用的时间为: 10.50 seconds\n","第2轮的测试F1分数: 0.8552\n","第3次训练开始了\n","Epoch [3], 第3轮：训练集损失: 0.3189, 验证集损失: 0.8675\n","测试集用的时间为: 7.80 seconds\n","第3轮的测试F1分数: 0.8864\n","第4次训练开始了\n","Epoch [4], 第4轮：训练集损失: 0.3094, 验证集损失: 0.7095\n","测试集用的时间为: 10.07 seconds\n","第4轮的测试F1分数: 0.8809\n","第5次训练开始了\n","Epoch [5], 第5轮：训练集损失: 0.3104, 验证集损失: 0.3738\n","测试集用的时间为: 9.35 seconds\n","第5轮的测试F1分数: 0.8591\n","第6次训练开始了\n","Epoch [6], 第6轮：训练集损失: 0.3171, 验证集损失: 0.7748\n","测试集用的时间为: 8.26 seconds\n","第6轮的测试F1分数: 0.8737\n","第7次训练开始了\n","Epoch [7], 第7轮：训练集损失: 0.3196, 验证集损失: 1.9783\n","测试集用的时间为: 10.57 seconds\n","第7轮的测试F1分数: 0.8705\n","Epoch 00007: reducing learning rate of group 0 to 1.0000e-04.\n","第8次训练开始了\n","Epoch [8], 第8轮：训练集损失: 0.2978, 验证集损失: 1.4236\n","测试集用的时间为: 9.48 seconds\n","第8轮的测试F1分数: 0.8715\n","第9次训练开始了\n","Epoch [9], 第9轮：训练集损失: 0.2711, 验证集损失: 0.6284\n","测试集用的时间为: 8.40 seconds\n","第9轮的测试F1分数: 0.8692\n","第10次训练开始了\n","Epoch [10], 第10轮：训练集损失: 0.2765, 验证集损失: 0.7621\n","测试集用的时间为: 10.47 seconds\n","第10轮的测试F1分数: 0.8973\n","第11次训练开始了\n","Epoch [11], 第11轮：训练集损失: 0.2621, 验证集损失: 0.8178\n","测试集用的时间为: 8.93 seconds\n","第11轮的测试F1分数: 0.8688\n","第12次训练开始了\n","Epoch [12], 第12轮：训练集损失: 0.2616, 验证集损失: 1.4223\n","测试集用的时间为: 8.62 seconds\n","第12轮的测试F1分数: 0.8561\n","第13次训练开始了\n","Epoch [13], 第13轮：训练集损失: 0.2559, 验证集损失: 0.7358\n","测试集用的时间为: 10.59 seconds\n","第13轮的测试F1分数: 0.8769\n","第14次训练开始了\n","Epoch [14], 第14轮：训练集损失: 0.2561, 验证集损失: 1.0457\n","测试集用的时间为: 9.32 seconds\n","第14轮的测试F1分数: 0.8948\n","Epoch 00014: reducing learning rate of group 0 to 1.0000e-05.\n","第15次训练开始了\n","Epoch [15], 第15轮：训练集损失: 0.2476, 验证集损失: 1.0294\n","测试集用的时间为: 8.02 seconds\n","第15轮的测试F1分数: 0.8744\n","第16次训练开始了\n","Epoch [16], 第16轮：训练集损失: 0.2492, 验证集损失: 0.8106\n","测试集用的时间为: 9.79 seconds\n","第16轮的测试F1分数: 0.8759\n","第17次训练开始了\n","Epoch [17], 第17轮：训练集损失: 0.2392, 验证集损失: 1.1517\n","测试集用的时间为: 10.38 seconds\n","第17轮的测试F1分数: 0.8842\n","第18次训练开始了\n","Epoch [18], 第18轮：训练集损失: 0.2467, 验证集损失: 1.0684\n","测试集用的时间为: 7.90 seconds\n","第18轮的测试F1分数: 0.8772\n","Epoch 00018: reducing learning rate of group 0 to 1.0000e-06.\n","第19次训练开始了\n","Epoch [19], 第19轮：训练集损失: 0.2481, 验证集损失: 1.0858\n","测试集用的时间为: 10.08 seconds\n","第19轮的测试F1分数: 0.8779\n","第20次训练开始了\n"]}],"source":["# 训练循环\n","num_epochs = 0\n","consecutive_f1_count = 0\n","\n","while num_epochs < 100:\n","    print(f'第{num_epochs+1}次训练开始了')\n","    vgg16_model.train()  # 设置模型为训练模式\n","    train_loss = 0.0\n","    for inputs, labels in train_loader:\n","        inputs, labels = inputs.to(device), labels.to(device)\n","\n","        # 将数据传递给模型\n","        outputs = vgg16_model(inputs)\n","\n","        # 计算损失\n","        loss = criterion(outputs, labels)\n","\n","        # 反向传播和优化\n","        optimizer.zero_grad()\n","        loss.backward()\n","        optimizer.step()\n","\n","        train_loss += loss.item()\n","\n","    # 在每个 epoch 结束时进行验证\n","    val_loss = 0.0\n","    with torch.no_grad():\n","        for inputs, labels in val_loader:\n","            inputs, labels = inputs.to(device), labels.to(device)\n","\n","            # 在验证集上进行推理，可根据需要添加评估代码\n","            val_outputs = vgg16_model(inputs)\n","            val_loss += criterion(val_outputs, labels).item()\n","\n","    # 计算平均训练损失\n","    avg_train_loss = train_loss / len(train_loader)\n","\n","    # 计算平均验证损失\n","    avg_val_loss = val_loss / len(val_loader)\n","\n","    # 打印训练过程中的损失和验证损失\n","    print(f'Epoch [{num_epochs+1}], 第{num_epochs+1}轮：训练集损失: {avg_train_loss:.4f}, 验证集损失: {avg_val_loss:.4f}')\n","\n","    # 在模型训练完后，使用测试集进行最终评估\n","    vgg16_model.eval()\n","    all_predictions = []\n","    all_labels = []\n","    start_time = time.time()  # 记录开始时间\n","    with torch.no_grad():\n","        for inputs, labels in test_loader:\n","            inputs, labels = inputs.to(device), labels.to(device)\n","\n","            # 在测试集上进行推理\n","            outputs = vgg16_model(inputs)\n","\n","            # 将预测结果和真实标签保存\n","            _, predicted = torch.max(outputs, 1)\n","            all_predictions.extend(predicted.cpu().numpy())\n","            all_labels.extend(labels.cpu().numpy())\n","\n","    end_time = time.time()  # 记录结束时间\n","    elapsed_time = end_time - start_time\n","    print(f'测试集用的时间为: {elapsed_time:.2f} seconds')\n","\n","    # 计算F1分数\n","    f1 = f1_score(all_labels, all_predictions, average='binary')  # 适用于二分类问题\n","\n","    # 打印每轮的测试F1分数\n","    print(f'第{num_epochs+1}轮的测试F1分数: {f1:.4f}')\n","\n","    # 如果达到条件，增加计数器；否则，重置计数器\n","\n","    # 调整学习率\n","    scheduler.step(f1)\n","\n","    # 增加训练次数\n","    num_epochs += 1\n"]},{"cell_type":"code","source":[],"metadata":{"id":"qxcXrSLZu3NL"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"17zE0hpQUmZ_"},"source":[]},{"cell_type":"markdown","metadata":{"id":"9CDZt6ntUs6A"},"source":[]},{"cell_type":"markdown","metadata":{"id":"RiHbqxyKLMPb"},"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"fGDQPX-euWil"},"outputs":[],"source":["# # 训练循环\n","# num_epochs=0\n","# while True:\n","#     print(f'第{num_epochs+1}次训练开始了')\n","#     vgg16_model.train()  # 设置模型为训练模式\n","#     train_loss = 0.0\n","#     for inputs, labels in train_loader:\n","#         inputs, labels = inputs.to(device), labels.to(device)\n","\n","#         # 将数据传递给模型\n","#         outputs = vgg16_model(inputs)\n","\n","#         # 计算损失\n","#         loss = criterion(outputs, labels)\n","\n","#         # 反向传播和优化\n","#         optimizer.zero_grad()\n","#         loss.backward()\n","#         optimizer.step()\n","\n","#         train_loss += loss.item()\n","\n","#     # 在每个 epoch 结束时进行验证\n","#     val_loss = 0.0\n","#     with torch.no_grad():\n","#         for inputs, labels in val_loader:\n","#             inputs, labels = inputs.to(device), labels.to(device)\n","\n","#             # 在验证集上进行推理，可根据需要添加评估代码\n","#             val_outputs = vgg16_model(inputs)\n","#             val_loss += criterion(val_outputs, labels).item()\n","\n","#     # 计算平均训练损失\n","#     avg_train_loss = train_loss / len(train_loader)\n","\n","#     # 计算平均验证损失\n","#     avg_val_loss = val_loss / len(val_loader)\n","\n","#     # 打印训练过程中的损失和验证损失\n","#     print(f'Epoch [{num_epochs+1}], 第{num_epochs+1}轮：训练集损失: {avg_train_loss:.4f}, 验证集损失: {avg_val_loss:.4f}')\n","\n","#     # 在模型训练完后，使用测试集进行最终评估\n","#     vgg16_model.eval()\n","#     all_predictions = []\n","#     all_labels = []\n","#     start_time = time.time()  # 记录开始时间\n","#     with torch.no_grad():\n","#         for inputs, labels in test_loader:\n","#             inputs, labels = inputs.to(device), labels.to(device)\n","\n","#             # 在测试集上进行推理\n","#             outputs = vgg16_model(inputs)\n","\n","#             # 将预测结果和真实标签保存\n","#             _, predicted = torch.max(outputs, 1)\n","#             all_predictions.extend(predicted.cpu().numpy())\n","#             all_labels.extend(labels.cpu().numpy())\n","\n","#     end_time = time.time()  # 记录结束时间\n","#     elapsed_time = end_time - start_time\n","#     print(f'测试集用的时间为: {elapsed_time:.2f} seconds')\n","\n","#     # 计算F1分数\n","#     f1 = f1_score(all_labels, all_predictions, average='binary')  # 适用于二分类问题\n","\n","#     # 打印每轮的测试F1分数\n","#     print(f'第{num_epochs+1}轮的测试F1分数: {f1:.4f}')\n","\n","#     # 如果达到条件，保存模型并退出训练\n","#     if f1 >= 0.92:\n","#         torch.save(vgg16_model.state_dict(), 'vgg16model.pth')\n","#         break\n","\n","#     # 调整学习率\n","#     scheduler.step(f1)\n","\n","#     # 增加训练次数\n","#     num_epochs += 1\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"RwtSuiGn3VlS"},"outputs":[],"source":["import torch\n","from torch.utils.data import DataLoader\n","from sklearn.metrics import f1_score\n","\n","# Assuming you have already defined and trained your model\n","# vgg16_model = ... (your model definition)\n","\n","# Load the saved weights\n","vgg16_model.load_state_dict(torch.load('your_model.pth'))\n","\n","# Set the model to evaluation mode\n","vgg16_model.eval()\n","\n","# Move the model to GPU if available\n","device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n","vgg16_model = vgg16_model.to(device)\n","\n","# Assuming you have a DataLoader for the test dataset (test_loader)\n","all_predictions = []\n","all_labels = []\n","\n","with torch.no_grad():\n","    for inputs, labels in test_loader:\n","        inputs, labels = inputs.to(device), labels.to(device)\n","        outputs = vgg16_model(inputs)\n","        _, predicted = torch.max(outputs, 1)\n","        all_predictions.extend(predicted.cpu().numpy())\n","        all_labels.extend(labels.cpu().numpy())\n","\n","# Calculate F1 score\n","f1 = f1_score(all_labels, all_predictions, average='binary')  # Adjust the 'average' parameter if needed\n","\n","print(f'Test F1 Score: {f1:.4f}')\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"xx89vsKdSoXg"},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PeCiFN8kuYJc"},"outputs":[],"source":["import matplotlib.pyplot as plt\n","import numpy as np\n","\n","# 选择一张 test_loader 中的图片\n","sample_image, true_label = next(iter(test_loader))\n","\n","# 将图片传递给模型进行预测\n","sample_image = sample_image.to(device)\n","with torch.no_grad():\n","    model_output = vgg16_model(sample_image)\n","\n","# 获取预测结果\n","_, predicted_label = torch.max(model_output, 1)\n","\n","# 转换为 NumPy 数组\n","sample_image = sample_image.cpu().numpy()[0]  # 将数据从 GPU 移回 CPU 并取出第一张图片\n","predicted_label = predicted_label[0].item()\n","\n","true_label = true_label[0].item()  # 直接获取标量值\n","\n","# 获取类别标签\n","class_labels = ['NORMAL', 'PNEUMONIA']\n","\n","# 显示图像\n","plt.imshow(np.transpose(sample_image, (1, 2, 0)))  # 转置图片的维度顺序\n","plt.title(f'TRUE LABEL IS: {class_labels[true_label]}, PREDICT LABEL IS: {class_labels[predicted_label]}')\n","plt.axis('off')\n","plt.show()\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"h_VV6TxKpghl"},"outputs":[],"source":["class CustomVGG16(nn.Module):\n","    def __init__(self):\n","        super(CustomVGG16, self).__init__()\n","        self.vgg16_model = models.vgg16(pretrained=True)\n","        for param in self.vgg16_model.features.parameters():\n","            param.requires_grad = False\n","        num_features = self.vgg16_model.classifier[6].in_features\n","        self.vgg16_model.classifier[6] = nn.Sequential(\n","            nn.Linear(num_features, 512),\n","            nn.ReLU(),\n","            nn.Dropout(0.5),\n","            nn.Linear(512, 2)\n","        )\n","\n","    def forward(self, x):\n","        return self.vgg16_model(x)\n","\n","# 创建 CustomVGG16 模型实例\n","vgg16_model = CustomVGG16()\n","\n","# 加载权重\n","vgg16_model.vgg16_model.load_state_dict(torch.load('your_model.pth'))\n","\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pINwdZG_qtoR"},"outputs":[],"source":["vgg16_model"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Q8LWH0Rxol7N"},"outputs":[],"source":["\n","# 将模型移动到CPU\n","device = torch.device('cpu')\n","vgg16_model.to(device)\n","\n","# 重新构建优化器\n","optimizer = optim.Adam(vgg16_model.parameters(), lr=0.001, weight_decay=1e-4)\n","\n","# 使用Intel Extension for PyTorch进行优化\n","vgg16_model, optimizer = ipex.optimize(model=vgg16_model, optimizer=optimizer, dtype=torch.float32)\n","\n","\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"eV-fE920rGut"},"outputs":[],"source":["vgg16_model.eval()\n","\n","# Assuming you have a DataLoader for the test dataset (test_loader)\n","all_predictions = []\n","all_labels = []\n","start_time = time.time()\n","\n","with torch.no_grad():\n","    for inputs, labels in test_loader:\n","        inputs, labels = inputs.to(device), labels.to(device)\n","        outputs = vgg16_model(inputs)\n","        _, predicted = torch.max(outputs, 1)\n","        all_predictions.extend(predicted.cpu().numpy())\n","        all_labels.extend(labels.cpu().numpy())\n","\n","end_time = time.time()  # 记录结束时间\n","elapsed_time = end_time - start_time\n","print(f'测试集用的时间为: {elapsed_time:.2f} seconds')\n","f1 = f1_score(all_labels, all_predictions, average='binary')  # 适用于二分类问题\n","# 打印每轮的测试F1分数\n","print(f'F1分数为: {f1:.4f}')"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"7G8RkwUjRANz"},"outputs":[],"source":[]}],"metadata":{"accelerator":"GPU","colab":{"provenance":[],"gpuType":"T4","authorship_tag":"ABX9TyNK4rb1XPx5NxdS2e+AgFUN"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}